/* autogenerated by Processing revision 1286 on 2023-03-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import processing.serial.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class propagation_a_etudier extends PApplet {

int recordingTimeSec = 4; // // nombre de secondes d'enregistrement dans la fonction sampling (qui n'est pas là)
int networkSize = 6; // number of ball
String debug ="";  // pour lire les bug // not used

// LIBRARY PERSPECTIVE

PeasyCam cam;

// LIBRARY TO READ SERIAL PORT 

Serial DueSerialNativeUSBport101; // To read actual position of encoder
Serial teensyport; // To send data to motor

// MANAGE SETUP of PEREPECTIVE 3D (point of view of camera)    
// change these for screen size
float fov = 45;  // degrees
float w = 1000;
float h = 800;

// don't change these
float cameraZ, zNear, zFar;
float w2 = w / 2;
float h2 = h / 2;
// END CAMERA SETTING

int nbBalls = networkSize-0;  // number of ball in function drawBall
int j; // number of the ball following the previous ball

int oscillatorChange, oldOscillatorChange; //  // renvoie le numero de la 'balle' sur laquelle on module une position, une phase. oldOscillatorChange donne le numero de l'ancienne balle sur laquelle on modulait une position
int nbMaxDelais= 1000; //TOTAL du delais de suivi entre chaque ball (en frame). Exemple si il y a un delai de 2 frames par balle et
//que nous avons 12 balles alors le delai total entre la premiere et derniere balle est de (12-1) * 2  = 22

// la phase est la position en radian sur un cercle. Elle est située entre 0 et deux * pi, TWO_PI. 

float netPhase [] =  new float  [networkSize];  // renvoie la phase de chaque balle.

float signalToSplit, oldSignalToSplit ;  // signal oscillant entre 0 et 1 ou entre - TWO_PI et TWO_PI. oldSignalTosplit est la valeur du signal a la frame precedente. 

int splitTime, oldSplitTime; // renvoie la valeur discontine du timeLFO. Quand timeLFO va de 0 à 1000, splitTimeLfo renvoie la valeur restante du timeLfo

float timeLfo; // met à l'echelle le "signalToSplit" afin qu'il soit limité entre 0 et 1000

float splitTimeLfo, oldSplitTimeLfo; // renvoie la valeur discontine du timeLFO. Quand timeLFO va de 0 à 1000, splitTimeLfo renvoie la valeur restante du timeLfo

float propagationSpeed; // " vitesse " à laquelle on change d'oscillateur

int phaseOffset;

boolean way;

float phaseFollowLFO [] =  new float  [networkSize]; // phase à suivre

float lfoPhase [] =  new float  [networkSize];   // tableau avec different motif de forme d'onde. Il peut y avoir des ondes en dents de scie et des ondes sinusoidales.

float signal [] =  new float  [networkSize];  // tableau où l'on va mettre different signaux (continue, sinusoidale, triangle..)

float LFO [] =  new float  [networkSize]; // tableau où l'on met les données des phases

float newPosXaddSignal [] =  new float  [networkSize]; // tableau avec les nouvelles positions des moteurs des balles

float phaseKeptAtChange [] =  new float  [networkSize]; // tableau avec les dernieres positions enregistrees des balles

boolean doQ, doZ; // faitQ, faitZ ==> change de sens de propagation

char letter;  //  pour aller vers le cas correspondant à la lettre Q, ou Z

boolean oscillatorChanged; // si on change d'oscillateur renvoie l'état est  Vrai sinon renvoie faux.  oldOscillatorChange renvoie si il y a eu un changement d'oscillateur à la frame precedente. 

char formerFormerKey, formerKey; // enregistre les lettres tapées sur le clavier // pas utilisé pour l'instant

int dataMappedForMotor [] =  new int [networkSize];   // renvoie le numero de la 'balle' sur laquelle on module une position, une phase
int [] revLfo = new int [networkSize]; // pour conter le nombre de tour // not used
int numberOfStep = 6400; // nombre de pas du moteur

int [] DataToDueCircularVirtualPosition = new int [networkSize];  // position à envoyer à la la carte Teensy pour controler les moteurs

public void settings() { // configure l'ecran par 600 pixel et en 3D
  size(600, 600, P3D);
}

 public void setup(){
  //***************************************** SET 3D CAM 
  cam = new PeasyCam(this, 2000);
  cameraZ = (h / 2.0f) / tan(radians(fov) / 2.0f);
  zNear = cameraZ / 10.0f;
  zFar = cameraZ * 10.0f;
  println("CamZ: " + cameraZ);
  rectMode(CENTER);
  //***************************************** END 3D CAM 
  frameRate(30); // nombre d'image ou de main loop par seconde
  
  //teensyport = new Serial(this,Serial.list()[1],115200); // to send datas of positions to control motors
}
 public void draw() 
{ 
  background(0);
  translate(width/2, -height/2, -1000);// To set the center of the perspective
 
  propagationMode();
//  CI DESSOUS 
//  rotate(-HALF_PI ); //TO change the beginning of the 0 (cercle trigo) and the cohesion point to - HALF_PI   
//  float lastBallPosition =  map (position.x, 0, 300, 0, TWO_PI); //  assigne à les positions x (celles qui viennent du sample non integré ici ) à la variable lastBallPosition. La balle la plus en avant de la machine
//  ballManager.updateAndDraw(lastBallPosition); // CLASSE ballManager utilisé plus tard avec le sample des coordoonées x
}
 public void keyReleased (){ 
  controlPropagation();
   }
  
 public void controlPropagation(){
  if (key!='#') { 
  
  if (keyCode == LEFT) {  
    phaseOffset-=1;
  }
  if (keyCode == RIGHT) { 
    phaseOffset+=1;
  }
  
  if (keyCode == UP) {     
    way=false;
   
  }
  
  if (keyCode == DOWN) {
    way=true;
     
  }
  

  
   }  
  key='#';
 } 
   public void drawBallGeneral(int n, float phase) 
  { 
        pushMatrix();
        translate(-w2, -h2, -1000);
        noStroke();
        float side = height*0.15f*1/this.nbBalls;
        float rayon = width/2; 
        float x = rayon*cos(phase);
        float y = rayon*sin(phase);
        translate (x, y, 200+(50*5*n));  
        colorMode(RGB, 255, 255, 255);
        fill( 0, 255, 0 ); 
        sphere(side*3);
        popMatrix();
  }
 public void propagationMode(){ 

     textSize (100);  // AFFICHE les textes ci dessous à la taille 100
     text ("Change way of propagation with q or z ", -width-200, -height- 600 );
     text ("signal2 " +nf(signal[2], 0, 2) + " intervalle de temps " + splitTimeLfo, -width-200, -height- 500 );
     text (" oldOscillatorChange " + oldOscillatorChange + " oscillatorChange " + oscillatorChange, -width-200, -height- 400 );
     text (" propagationSpeed " + propagationSpeed + " key " + key, -width-200, -height- 300 );
     
  
   if (key=='q' || key=='z' ) { // enregistre la lettre
     letter = key;   
     }
     
  switch(letter) {
    case 'q': // change way of propagation
    doZ=false;
    break;
    case 'z': // change way of propagation
    doZ=true;
    break;
    }
  propagationSpeed=50.0f;
  splitTimeScale(propagationSpeed); //  50.0=> vitesse de propagation. On change de sens de ROTATION avec q et z.
 // ici le signal de propagation est continue, alors chaque intervalle de temps de 10% est équi-temporel
 // splitTimeLfoScale();  // // ici le signal de propagation est sinusoidale, alors chaque intervalle de temps de 10% varie. Surtout quand le signal est au crête


  //  AJOUT GESTION du decalage entre les boules et du sens de propagation

  // A l'avenir cette fonction devra gerer la position des balles qui ont ete changées.
  // les boules devront toutes avoir des vitesses de rotations identiques sauf unes.
  // La boule avec la vitesse de rotation differente (*1,5/ aux autres) devra donner sa vitesse à celle d'apres où à la precedente
//  controlPropagation(1, true);
  propagation2way(); 
  

  //****  affiche les balles à l'ecran  ****
 
  for (int k = 0; k < this.nbBalls; k++) 
     {    
        drawBallGeneral(k, newPosXaddSignal[k] );  
     }     
   }
 
  public void propagation2way() { // dans cette example de propagation, les balles tournent dans le meme sens dans les deux cas.
 // Donc les deux conditions vraie et fausse de doZ sont les mêmes 
 // phaseKeptAtChange[oscillatorChange]=newPosXaddSignal[oldOscillatorChange]; // on l'utilisera plus tard
      
  // controlPropagation();  
 // keyReleasedPropagation();
   doZ=way;
   println (" way " + way + " phaseOffset " + phaseOffset );
   if (doZ==true){ 

       LFO[oscillatorChange] =  LFO[oldOscillatorChange]+QUARTER_PI*phaseOffset/2 ;  // on ajoute à la position de la balle precedente QUARTER_PI*1/2 afin que la balle qui est en train de changer
       LFO[oscillatorChange] =  LFO[oscillatorChange]%TWO_PI; // la phase est toujours comprise entre 0 et TWO_PI
       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
 
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI); // met à l'echelle les positions pour les moteurs
     }
     
    if (doZ==false){ 

       LFO[oscillatorChange] =  LFO[oldOscillatorChange]+QUARTER_PI*phaseOffset/2 ;  //
       LFO[oscillatorChange] =  LFO[oscillatorChange] %TWO_PI; //

       dataMappedForMotor[oscillatorChange]= (int) map (LFO[oscillatorChange], 0, TWO_PI , 0, numberOfStep);  // 
       println (" true phaseKeptAtChange[oscillatorChange] ", oscillatorChange, " " ,  phaseKeptAtChange[oldOscillatorChange]);
      
       newPosXaddSignal[oscillatorChange]= map (dataMappedForMotor[oscillatorChange], 0, numberOfStep, 0, TWO_PI);
     }
  }

   public void  splitTimeScale(float propagationSpeed) {  // fonction qui decoupe le temps de 10%. Apres 10%, la balle en mouvement change.
 // Soit la balle de derriere avec Z. // Soit la balle de devant avec q. 

    signal[2] = (0*PI + (frameCount / propagationSpeed) * cos (1000 / 500.0f)*-1)%1; // signal allant de 0 à 1. Si propagationSpeed est petit alors le signal va de 0 à 1 tres rapidement
         
if (doZ==false){  // la balle de derrière (nommée oscillatorChange) est celle qui change 
  if (oldSplitTimeLfo>splitTimeLfo){ // si l'intervalle de temps est passé
 
      oldOscillatorChange=oscillatorChange; // la balle changée (nommée oldOscillatorChange) prend la valeur de la balle qui change 
      oscillatorChange=oscillatorChange+1;// la balle qui change est maintenant la balle +1
   } 

      oscillatorChange=oscillatorChange%networkSize; // quand la balle atteint le nombre de balle totale alors la balle qui change est 0
     if (oscillatorChange<=0) { 
      oldOscillatorChange=networkSize-1; // si la balle qui change est 0 alors la balle changée est la balle 5 (6-1)
   } 
  }
  
if (doZ==true){ // la balle devant  (nommée oscillatorChange) est celle qui change 
   if (  oldSplitTimeLfo>splitTimeLfo){ // si l'intervalle de temps est passé

      oldOscillatorChange=oscillatorChange; // la balle changée (nommée oldOscillatorChange) prend la valeur de la balle qui change 
      oscillatorChange=oscillatorChange-1; // la balle qui change est maintenant la balle -1
   } 
   
      if (oscillatorChange<=-1) {
        oldOscillatorChange=0;
        oscillatorChange=networkSize-1;
   }
  }       
  
   timeLfo = (int) map (signal[2], 0, 1, 0, 1000); // linear time  to map between 0 and 1000
   println ( " ***************************************************    SPLIT TIME  timeLfoooooooooo " + " signal[2] " + signal[2] + " oldSplitTime " + oldSplitTime + " splitTime " + splitTime );

   oldSplitTimeLfo=splitTimeLfo;  // met à jour l'ancienne intervalle de temps
   splitTimeLfo= PApplet.parseInt  (timeLfo%100); // la valeur de l'intervalle de temps situé à sur un decile du signal[2]  
}


 public void  splitTimeLfoScale() {  // change de sens de propagagtion.   ATTENTION dans ce reglage le signalToSplit de propgation est UP continue de 0 à TWO_PI

    lfoPhase[1] = (frameCount / 10.0f * cos (1000 / 500.0f)*-1)%TWO_PI;  // continue 0 to TWO_PI;
    lfoPhase[3] = map ((((cos  (frameCount / 30.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI);  // sinusoidale lente
    lfoPhase[2] = map ((((cos  (frameCount / 100.0f))*-1) %2), -1, 1, -TWO_PI, TWO_PI); // sinusoidale rapide
    
    println (" forme d'onde lfoPhase[1] ", lfoPhase[1], "lfoPhase[2] ", lfoPhase[2], "lfoPhase[3]= signalTosplit ", lfoPhase[3]); 

    oldSignalToSplit=signalToSplit;
    signalToSplit= lfoPhase[3];
 
  if (oldSignalToSplit> signalToSplit ) {
  //  key = 'q' ; // when signal goes down --> propagation FRONT SIDE
   timeLfo= map (signalToSplit, TWO_PI, -TWO_PI, 0, 1000);  //  if we have an oscillation as  lfoPhase[3]
    }
  else if (oldSignalToSplit< signalToSplit ) { // on est dans cette configuration avec  signalToSplit= lfoPhase[1]
//   key = 'z';  //  when signal goes down --> propagation BEHIND SIDE 
//   key = 'q' ;  // propagation in on the same way
   timeLfo= map (signalToSplit, -TWO_PI, TWO_PI, 0, 1000);  // if we have an oscillation  lfoPhase[3]
 //**   timeLfo= map (signalToSplit, 0, TWO_PI, 0, 1000);  // if we have a continuois from 0 to TWO_PI 
 //   timeLfo= map (signalToSplit, 0, 1, 0, 1000); //  if we have a continuois from 0 to TWO_PI from an other software

   }

  int splitTimeLfo= PApplet.parseInt  (timeLfo%100);   // 100 is the size of the gate trigging the change of the ball  
   
      println ( " oldSignalToSplit " + oldSignalToSplit + " signalToSplit " + signalToSplit );
      print (" timeLfo "); print ( timeLfo );   print (" splittimeLfo "); println ( splitTimeLfo );


 if (doZ==false){  // case q
  if (oldSplitTimeLfo>splitTimeLfo){

      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange+1;
   } 
      oscillatorChange=oscillatorChange%networkSize;
      
  if (oscillatorChange<=0) {
  //    oscillatorChange=0;
      oldOscillatorChange=networkSize-1;
   } 
  }
  
 if (doZ==true){ // case z
  if (  oldSplitTimeLfo>splitTimeLfo){

      oldOscillatorChange=oscillatorChange;
      oscillatorChange=oscillatorChange-1;
   } 
      if (oscillatorChange<=-1) {

      oldOscillatorChange=0;
      oscillatorChange=networkSize-1;
   }
  }  

  if ( oldOscillatorChange!=oscillatorChange )
  {
   oscillatorChanged=true;
  } 
   oldSplitTimeLfo = splitTimeLfo;           
}

 


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "--full-screen", "--bgcolor=#666666", "--stop-color=#cccccc", "propagation_a_etudier" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
